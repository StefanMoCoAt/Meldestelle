#Kotlin
kotlin.code.style=official
kotlin.daemon.jvmargs=-Xmx2048M

#Gradle
org.gradle.jvmargs=-Xmx2048M -Dfile.encoding=UTF-8 -XX:+UseParallelGC
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configureondemand=true
#org.gradle.dependency.verification=strict # Aktiviere Dependency Verification bei Bedarf

#Ktor
io.ktor.development=true

#IDE
kotlin.build.report.output=build_scan
kotlin.mpp.androidSourceSetLayoutVersion=2
org.jetbrains.kotlin.wasm.check.wasm.binary.format=false
kotlin.native.ignoreDisabledTargets=true

#IntelliJ IDEA
idea.project.settings.delegate.build.run.actions.to.gradle=true

# Optimierungen für Dependency Resolution (können bei Konflikten helfen)
# Abhängigkeits-Locking aktivieren (empfohlen für reproduzierbare Builds und zur Vermeidung unerwarteter transitive Abhängigkeitsänderungen)
# org.gradle.dependency.locking.enabled=true

# Strikte Abhängigkeitsauflösung erzwingen (kann helfen, subtile Konflikte aufzudecken, aber erfordert sorgfältige Konfiguration)
# configurations.all*.resolutionStrategy.failOnVersionConflict()
# configurations.all*.resolutionStrategy.preferProjectModules() # Bevorzuge Subprojekte gegenüber externen Abhängigkeiten gleicher Identität

# Optimierung für große Multi-Modul-Projekte
# Aktiviert die Konfiguration von Projekten parallel, aber verzögert die eigentliche Ausführung von Tasks so lange wie möglich
# org.gradle.configureondemand=true # Bereits aktiviert
org.gradle.vfs.watch=true # Nutze das File System Watching für schnellere inkrementelle Builds (Gradle 6.5+)
org.gradle.unsafe.configuration-cache=true # Experimentelles Feature für schnelleren Build-Start (mit Vorsicht verwenden und testen)
