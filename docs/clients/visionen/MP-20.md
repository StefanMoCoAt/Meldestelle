## Frontend-Architektur

# Frontend-Architektur

**Architektur-Stil:** Feature-First, Clean Architecture, Kotlin Multiplatform (KMP)

## 1. Management Summary

Das Frontend wird als **modulare Kotlin Multiplatform (KMP) Anwendung** entwickelt. Ziel ist eine strikte Trennung von
technischer Basis (`shared`) und fachlichen Funktionen (`features`). Die Architektur ist **"Offline-Ready"** konzipiert:
Durch die konsequente Nutzung des Repository-Patterns kann die Datenquelle sp√§ter transparent von "Online-Only" (API)
auf "Local-First" (Datenbank + Sync) umgestellt werden, ohne die Benutzeroberfl√§che (UI) anpassen zu m√ºssen.

## 2. Die Modul-Struktur (Gradle)

Die Anwendung ist nicht monolithisch, sondern in fachliche Module geschnitten ("Feature-First").

- **`:clients:app` (Der Container)**

- **Rolle:** Der Einstiegspunkt ("Main").

- **Aufgabe:**

Initialisierung von Koin (Dependency Injection).

Globales Theming (Material3).

High-Level Navigation (Routing zwischen Features).

Verbindet alle Feature-Module.

- **`:clients:shared` (Das Fundament)**

- **Rolle:** Die gemeinsame Bibliothek f√ºr alle Features.

- **Inhalt:**

**DI (Dependency Injection):** Zentrale Koin-Module (NetworkModule, CoreModule).

**Network:** Konfigurierter HttpClient (Singleton).

**Domain Core:** Basis-Modelle (Resource<T>, ApiError, User).

**UI Kit:** Gemeinsame Komponenten (LoadingSpinner, ErrorView), Typography, Colors.

- **Regel:** Hier liegt keine Fachlogik eines spezifischen Features (keine Pferdedaten, keine Nennungen).

- **`:clients:*-feature` (Die Fachlichkeit)**

- **Beispiele:** `:clients:auth-feature`, `:clients:registry-feature`, `:clients:events-feature`.

- **Rolle:** Kapselt einen kompletten fachlichen Bereich.

- **Inhalt:** Eigene Screens, ViewModels und spezifische Use-Cases.

## 3. Die Schichten-Architektur (Innerhalb eines Moduls)

Jedes Modul (besonders `shared` und die Features) folgt einer strikten 3-Schichten-Architektur. Das garantiert
Testbarkeit und Austauschbarkeit.

### 1Ô∏è‚É£ Presentation Layer (UI)

- **Technologie:** Compose Multiplatform.

- **Komponenten:** `Screen` (Composable Functions) und `ViewModel` (State-Holder).

- **Verantwortung:**

Zeigt Daten an (Reagiert auf State).

Nimmt User-Input entgegen.

**Wei√ü NICHT**, woher die Daten kommen (Netzwerk oder DB).

Nutzt Repositories via Koin Injection (`koinInject()`).

### 2Ô∏è‚É£ Domain Layer (Die Logik)

- **Komponenten:** `Repository Interface`, `Models`.

- **Verantwortung:**

Definiert **WAS** getan werden kann (z.B. `checkSystemStatus()`).

Ist komplett unabh√§ngig von Frameworks (reines Kotlin).

Nutzt `Resource<T>` Wrapper (`Success`, `Error`, `Loading`) f√ºr den State-Transport.

### 3Ô∏è‚É£ Data Layer (Die Umsetzung)

- **Komponenten:** `Repository Implementation`, `API-DTOs`, `Database-Entities`.

- **Verantwortung:**

Entscheidet **WIE** Daten geholt werden.

**Aktuell (Online):** Ruft Ktor Client auf.

**Zukunft (Offline/LAN):** Pr√ºft lokale SQLite DB, synchronisiert im Hintergrund.

Mappt rohe API-Daten (DTOs) in saubere Domain-Modelle.

### 4. Technische Kern-Konzepte

**üíâ Dependency Injection (Koin)**

Wir nutzen Koin als "Klebstoff".

- Module exportieren ihre Funktionalit√§t via `val myModule = module { single { ... } }`.

- Die `clients:app` sammelt alle Module ein und startet den Container.

- **Vorteil:** Repositories und der HTTP-Client m√ºssen nicht manuell herumgereicht werden.

**üåê Networking (Ktor)**

Ein zentraler `HttpClient` im `NetworkModule` (`clients:shared`).

- Konfiguriert mit JSON-Serialization.

- Zentrale Base-URL Steuerung (via `AppConfig` umschaltbar f√ºr LAN/Dev/Prod).

- Timeout- und Logging-Handling an einer Stelle.

**üîÑ Datenfluss (Unidirectional Data Flow)**

1. **UI:** Trigger Event (Button Click).

2. **ViewModel/Scope:** Ruft Repository auf (`launch { repo.getData() }`).

3. **Repository:** Liefert `Resource.Loading` -> `Resource.Success(data)`.

4. **UI:** Rendert den neuen State.

### 5. Strategie f√ºr Offline & LAN-F√§higkeit (Zukunft)

Die aktuelle Architektur ist **vorbereitet** f√ºr die Offline-Anforderungen der gro√üen Turniere.

**Die Transition (Schritt-f√ºr-Schritt):**

1. **Phase 1 (Jetzt):** PingRepositoryImpl ruft direkt httpClient.get() auf.

2. **Phase 2 (Offline):**

Wir f√ºgen **SQLDelight** (lokale DB) hinzu.

Die `PingRepositoryImpl` wird ge√§ndert (ohne dass die UI es merkt!):

```Kotlin

fun getData() {
  
  val localData = db.dao.getAll()
  
  if (localData.isEmpty()) {
    
    val remote = api.getAll()
    
    db.dao.insert(remote)
    
    return remote
  
  }
  
  return localData

}

```

3. **Phase 3 (Sync):** Ein Hintergrund-Worker (`WorkManager` oder `Coroutine`) synchronisiert lokale √Ñnderungen mit dem
   Server, sobald das LAN verf√ºgbar ist.

### 6. Zusammenfassung f√ºr Entwickler

Wenn du ein neues Feature (z.B. "Pferde anzeigen") baust:

1. **Domain:** Erstelle Horse Model und HorseRepository Interface.

2. **Data:** Erstelle HorseRepositoryImpl. Injiziere den HttpClient.

3. **DI:** Registriere das Repository im Koin-Modul.

4. **UI:** Erstelle HorseListScreen. Injiziere das Repository.

5. Fertig.

Diese Struktur ist sauber, skalierbar und bereit f√ºr den professionellen Einsatz beim OEPS. ‚úÖ
